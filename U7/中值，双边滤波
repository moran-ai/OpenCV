1.线性滤波与非线性滤波
方框滤波、均值滤波和高斯滤波都是线性滤波器的原始数据与滤波结果是一种线性的算术运算，
即用加减乘除等运算实现，所以称之为线性滤波

2.中值滤波
简言之中值滤波就是把函数框（如图中的3 X 3）内的灰度值按顺序排列，
然后中值取代函数框中心的灰度值。所以一般采用奇数点的邻域来计算中值，
但如果像素点数为偶数，中值就取排序像素中间两点的平均值。

中值滤波在一定的条件下可以克服常见线性滤波器如方框滤波器、
均值滤波等带来的图像细节模糊，而且对滤除脉冲干扰及图像扫描噪声非常有效，
也常用于保护边缘信息, 保存边缘的特性使它在不希望出现边缘模糊的场合也很有用，
是非常经典的平滑噪声处理方法。

但是中值滤波的缺点也很明显，因为要进行排序操作，所以处理的时间长，是均值滤波的5倍以上。
中值滤波在OpenCV中用medianBlur函数实现，下面是函数声明：
void medianBlur( InputArray src, OutputArray dst, int ksize );
参数很简单，就是输入图像src，输出图像dst，以及核的大小ksize。
注意这里的ksize必须为正奇数1,3,5,7……否则程序会出错。

3.双边滤波
双边滤波（Bilateral filter）是一种非线性的滤波方法,
是结合图像的空间邻近度和像素值相似度的一种折衷处理，
同时考虑空域信息和灰度相似性，达到保边去噪的目的。具有简单、非迭代、局部的特点。
双边滤波器的好处是可以做边缘保存（edge preserving），
一般用高斯滤波去降噪，会较明显地模糊边缘，对于高频细节的保护效果并不明显。
双边滤波器顾名思义比高斯滤波多了一个高斯方差sigma－d，
它是基于空间分布的高斯滤波函数，所以在边缘附近，
离的较远的像素不会太多影响到边缘上的像素值，
这样就保证了边缘附近像素值的保存。但是由于保存了过多的高频信息，
对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，
只能够对于低频信息进行较好的滤波。

OpenCV中用medianBlur函数实现双边滤波
void bilateralFilter( InputArray src, OutputArray dst, int d,
                                   double sigmaColor, double sigmaSpace,
                                   int borderType = BORDER_DEFAULT );
参数：
第一个参数，InputArray类型的src，输入图像，即源图像，需要为8位或者浮点型单通道、
三通道的图像。
第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。
第三个参数，int类型的d，表示在过滤过程中每个像素邻域的直径。
如果这个值我们设其为非正数，那么OpenCV会从第五个参数sigmaSpace来计算出它来。
第四个参数，double类型的sigmaColor，颜色空间滤波器的sigma值。
这个参数的值越大，就表明该像素邻域内有更宽广的颜色会被混合到一起，
产生较大的半相等颜色区域。
第五个参数，double类型的sigmaSpace坐标空间中滤波器的sigma值，
坐标空间的标注方差。他的数值越大，意味着越远的像素会相互影响，
从而使更大的区域足够相似的颜色获取相同的颜色。
当d>0，d指定了邻域大小且与sigmaSpace无关。否则，d正比于sigmaSpace。
第六个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。
注意它有默认值BORDER_DEFAULT。

