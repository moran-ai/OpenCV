使用到的函数有：cv2.Sobel()，cv2.Schar()，cv2.Laplacian() 等
OpenCV 提供了三种不同的梯度滤波器，或者说高通滤波器：Sobel，Scharr 和Laplacian。
Sobel，Scharr 其实就是求一阶或二阶导数。Scharr 是对Sobel
（使用小的卷积核求解求解梯度角度时）的优化。Laplacian 是求二阶导数 。
对于图像一阶导数最大的是边缘（Sobel），对于二阶导数为0的是边缘（Laplacian ）

OpenCV的convertScaleAbs函数使用线性变换转换输入数组元素成8位无符号整型。
函数原型：convertScaleAbs(src[, dst[, alpha[, beta]]]) -> dst
src参数表示原数组。
dst参数表示输出数组 (深度为 8u)。
alpha参数表示比例因子。
beta参数表示原数组元素按比例缩放后添加的值

实列：
import cv2
def ScalAbs(img):
    # 第二个参数没有用，而且只有第二个 参数输入时，第三个参数（表示比例因子）才有效
    ScaleAbs_img = cv2.convertScaleAbs(img,1,0.5)
    cv2.imshow("img",img)
    cv2.imshow("ScaleAbs_img", ScaleAbs_img)

img=cv2.imread('1.jpg',0)
ScalAbs(img)
cv2.waitKey()

OpenCV的addWeighted函数是计算两个数组的加权和。
函数原型：addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]]) -> dst
src1参数表示需要加权的第一个输入数组。

alpha参数表示第一个数组的权重。

src2参数表示第二个输入数组，它和第一个数组拥有相同的尺寸和通道数。

beta参数表示第二个数组的权重。

gamma参数表示一个加到权重总和上的标量值。

dst参数表示输出的数组，它和输入的两个数组拥有相同的尺寸和通道数。

dtype参数表示输出数组的可选深度。当两个输入数组具有相同的深度时，
这个参数设置为-1（默认值），即等同于src1.depth（）
实列：
import cv2
from matplotlib import pyplot as plt
img=cv2.imread('drawing.png',0)
#cv2.CV_64F 输出图像的深度（数据类型），可以使用-1, 与原图像保持一致np.uint8
laplacian=cv2.Laplacian(img,cv2.CV_64F)
# 参数1,0 为只在x 方向求一阶导数，最大可以求2 阶导数。
sobelx=cv2.Sobel(img,cv2.CV_64F,1,0,ksize=5)
# 参数0,1 为只在y 方向求一阶导数，最大可以求2 阶导数。
sobely=cv2.Sobel(img,cv2.CV_64F,0,1,ksize=5)
plt.subplot(2,2,1),plt.imshow(img,cmap = 'gray')
plt.title('Original'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2,2),plt.imshow(laplacian,cmap = 'gray')
plt.title('Laplacian'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2,3),plt.imshow(sobelx,cmap = 'gray')
plt.title('Sobel X'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2,4),plt.imshow(sobely,cmap = 'gray')
plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])
plt.show()

